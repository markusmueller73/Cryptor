;  * CRYPTOR;  *;  * xml_functions.pbi;  *;--------------------------------------------------------------------------------;- macrosMacro _reset_cfg(var)  var\StrFormat = #APP_ENCODING  var\Vector    = #Null$  var\DefName   = #Null$  var\DefEmail  = #Null$  info("Config var resetted.")EndMacroMacro _reset_lst(lst)  If ListSize(lst) > 0    ClearList(lst)  EndIf  info("Database resetted.")EndMacro;--------------------------------------------------------------------------------Procedure.i xml_new( *c.CONFIGURATION , List d.DATASET() )  ;- begin xml_new()  Protected.i h_xml, x_root, x_data    h_xml = CreateXML(#PB_Any, #APP_ENCODING)    If IsXML(h_xml)        x_root = CreateXMLNode(RootXMLNode(h_xml), #APP_NAME)        ;-- insert config structure     InsertXMLStructure(x_root, *c, CONFIGURATION)        x_data = CreateXMLNode(x_root, UCase(#APP_DATATYPE_DB))        ;-- insert each dataset structure    ForEach d()      InsertXMLStructure(x_data, @d(), DATASET)    Next        info("New XML tree successful created.")      Else        warn("Can't create xml data.")    ProcedureReturn 0      EndIf    ProcedureReturn h_xml  ;- end xml_new()EndProcedure;--------------------------------------------------------------------------------Procedure.i xml_save( filename$ , *c.CONFIGURATION , List d.DATASET() , overwrite.b = #True )    Protected.i do_saving, h_xml    If FileSize(filename$) >= 0 And overwrite = #False    do_saving = MessageRequester(#app_name, LANGUAGE("DIALOG_DATABASE_ALREADY_EXIST_1") + ":" + #NL + filename$ + #NL + LANGUAGE("DIALOG_DATABASE_ALREADY_EXIST_2"), #PB_MessageRequester_YesNo)    If do_saving = #PB_MessageRequester_Yes      info("User decision, the file '" + filename$ + "' will be overwritten.")    Else      warn("The file '" + filename$ + "' already exists, aborted saving.")      ProcedureReturn 0    EndIf  EndIf    If ListSize(d()) = 0    info("Creating xml file with no data.")  EndIf    h_xml = xml_new(*c, d())  If IsXML(h_xml)        If XMLStatus(h_xml) = #PB_XML_Success            ;FormatXML(h_xml, #PB_XML_ReFormat)      If SaveXML(h_xml, filename$, #PB_XML_StringFormat)        info("The file '" + filename$ + "' with a new xml tree was successfully created.")      Else        warn("Can't save xml tree as file '" + filename$ + "'.")        FreeXML(h_xml)        ProcedureReturn 0      EndIf          Else      warn("Created xml tree with error: " + XMLError(h_xml) + ", at line " + XMLErrorLine(h_xml) + " and at column " + XMLErrorPosition(h_xml) + ".")      FreeXML(h_xml)      ProcedureReturn 0    EndIf      Else    warn("Can't create new xml tree.")    ProcedureReturn 0  EndIf    FreeXML(h_xml)    ProcedureReturn FileSize(filename$)  EndProcedure;--------------------------------------------------------------------------------Procedure.i xml_load( filename$ , *c.CONFIGURATION , List d.DATASET() )    Protected.i h_xml, x_root, x_child, x_subchild, nb_childs, n    If FileSize(filename$) < 0    warn("The file '" + filename$ + "' didn't exist.")    ProcedureReturn 0  EndIf    h_xml = LoadXML(#PB_Any, filename$, #APP_ENCODING)  If IsXML(h_xml)        If XMLStatus(h_xml) = #PB_XML_Success            _reset_cfg(*c)      _reset_lst(d())            info("XML file '" + filename$ + "' successfully loaded.")            x_root = MainXMLNode(h_xml)      If GetXMLNodeName(x_root) = #APP_NAME And XMLNodeType(x_root) = #PB_XML_Normal                x_child = ChildXMLNode(x_root)        While x_child <> 0                    If GetXMLNodeName(x_child) = UCase(#APP_DATATYPE_CFG)                        ExtractXMLStructure(x_child, *c, CONFIGURATION)            info("Found configuration structure.")                      ElseIf GetXMLNodeName(x_child) = UCase(#APP_DATATYPE_DB)                        nb_childs = XMLChildCount(x_child)            x_subchild = ChildXMLNode(x_child)            While x_subchild <> 0              AddElement(d())              ExtractXMLStructure(x_subchild, @d(), DATASET)              x_subchild = NextXMLNode(x_subchild)            Wend            info("Found database structure.")                      EndIf                    x_child = NextXMLNode(x_child)                  Wend                If ListSize(d()) = 0          info("There are no entries in the xml database.")        EndIf              Else        warn("The xml main node have a wrong name: '" + GetXMLNodeName(x_root) + "' or a wrong type.")        FreeXML(h_xml)        ProcedureReturn 0      EndIf          Else      warn("The xml file has an error: " + XMLError(h_xml) + ", at line " + XMLErrorLine(h_xml) + " and at column " + XMLErrorPosition(h_xml) + ".")      FreeXML(h_xml)      ProcedureReturn 0    EndIf      Else    warn("Can't load xml file '" + filename$ + "'.")    ProcedureReturn 0  EndIf    FreeXML(h_xml)    ProcedureReturn nb_childs  EndProcedure;--------------------------------------------------------------------------------Procedure.i xml_load_crypted( filename$ , *vec , *c.CONFIGURATION , List d.DATASET() )  ;- begin xml_load_crypted()  Protected.i h_file, content_size, null_byte  Protected.i h_xml, x_root, x_child, x_subchild, nb_childs, n  Protected.i *content, *encrypted, *key = AllocateMemory(#APP_KEY_SIZE)    null_byte = StringByteLength(Str($0), #APP_ENCODING)    ;-- check for valid vector  If *vec = 0    warn("The mem pointer [vector] was NULL.")    ProcedureReturn 0  EndIf    ;-- check if file exists  If FileSize(filename$) < 0    warn("The file '" + filename$ + "' didn't exist.")    ProcedureReturn 0  EndIf    ;-- open file  h_file = ReadFile(#PB_Any, filename$)  If IsFile(h_file) ;--- success        ;--- check if magic number fits    If ReadLong(h_file) = #APP_EXT_L            ;---- read the vector from file      ReadData(h_file, *vec, #APP_VEC_SIZE)            ;---- read the size in bytes of the crypted content      content_size = ReadLong(h_file)            ;---- allocate memory for the crypted and encrypted data      *content = AllocateMemory(content_size + null_byte)      *encrypted = AllocateMemory(content_size + null_byte)            ;---- read the crypted data      ReadData(h_file, *content, content_size + null_byte)            CloseFile(h_file)            ;---- ask for password      get_pwd(*key)            If AESDecoder(*content, *encrypted, content_size, *key, #APP_AES_SIZE, *vec, #PB_Cipher_CBC)        ;----- decryption succesful, delete password        clear_mem(*key)                ;----- get XML data from encrypted mem position        h_xml = CatchXML(#PB_Any, *encrypted, content_size, 0, #APP_ENCODING)                FreeMemory(*encrypted) : FreeMemory(*content)                If IsXML(h_xml) ;------ success                    If XMLStatus(h_xml) = #PB_XML_Success ;------- the XML data is valid and has no errors                        _reset_cfg(*c)            _reset_lst(d())                        info("The decrypted file '" + filename$ + "' was successfully loaded.")                        x_root = MainXMLNode(h_xml)            If GetXMLNodeName(x_root) = #APP_NAME And XMLNodeType(x_root) = #PB_XML_Normal ;-------- xml tree structure is valid                            ;-------- get the XML tree content              x_child = ChildXMLNode(x_root)              While x_child <> 0                                If GetXMLNodeName(x_child) = UCase(#APP_DATATYPE_CFG)                                    ;--------- get the config vars                  ExtractXMLStructure(x_child, *c, CONFIGURATION)                  info("Found configuration structure.")                                  ElseIf GetXMLNodeName(x_child) = UCase(#APP_DATATYPE_DB)                                    ;--------- get the database                  nb_childs = XMLChildCount(x_child)                  x_subchild = ChildXMLNode(x_child)                  While x_subchild <> 0                    AddElement(d())                    ExtractXMLStructure(x_subchild, @d(), DATASET)                    x_subchild = NextXMLNode(x_subchild)                  Wend                  info("Found database structure, read " + Str(ListSize(d())) + " dataset(s).")                                  EndIf                                x_child = NextXMLNode(x_child)                              Wend                            ;-------- all done, clean up              FreeXML(h_xml)                          Else                            ;-------- break-> XML tree structure isn't valid, wrong identifier              warn("The xml main node have a wrong name: '" + GetXMLNodeName(x_root) + "' or a wrong type.")              FreeXML(h_xml)              ProcedureReturn 0                          EndIf                      Else                        ;------- break-> the XML data has errors            warn("The xml file has an error: " + XMLError(h_xml) + ", at line " + XMLErrorLine(h_xml) + " and at column " + XMLErrorPosition(h_xml) + ".")            FreeXML(h_xml)            ProcedureReturn #Null                      EndIf                  Else                    ;------ break-> the XML data isn't valid          warn("Can't get encrypted XML database from memory.")          ProcedureReturn #Null                  EndIf              Else                ;----- break-> encryption failed        clear_mem(*key)        FreeMemory(*encrypted) : FreeMemory(*content)        warn("Can't decrypt the content.")        ProcedureReturn #Null              EndIf          Else            ;---- break-> file isn't valid      warn("No valid crypted file: '" + filename$ + "'.")      ProcedureReturn #Null          EndIf      Else        ;--- break-> can't open file    warn("Can't open and read the file '" + filename$ + "'.")    ProcedureReturn #Null      EndIf    ProcedureReturn content_size  ;- end xml_load_encrypted()EndProcedure;--------------------------------------------------------------------------------Procedure.i xml_save_crypted( filename$ , *vec , *c.CONFIGURATION , List d.DATASET() , overwrite.b = #True )    ;- begin xml_save_crypted()  Protected.b do_saving                         ; answer for overwrite  Protected.i h_xml                             ; handle of XML data  Protected.i h_file, content_size, null_byte   ; handle of file  Protected.i *content, *decrypted, *key        ; pointer    ;-- create the encoding depended NULL byte  null_byte = StringByteLength(Str($0), #APP_ENCODING)    ;-- check for valid vector  If *vec = 0    warn("mem pointer [vector] was NULL.")    ProcedureReturn 0  EndIf    ;-- check if file already exists  If FileSize(filename$) >= 0 And overwrite = #False        do_saving = MessageRequester(#app_name, LANGUAGE("DIALOG_DATABASE_ALREADY_EXIST_1") + ":" + #NL + filename$ + #NL + LANGUAGE("DIALOG_DATABASE_ALREADY_EXIST_2"), #PB_MessageRequester_YesNo)        If do_saving = #PB_MessageRequester_Yes      info("User decision, the file '" + filename$ + "' will be overwritten.")    Else      warn("The file '" + filename$ + "' already exists, aborted saving.")      ProcedureReturn 0    EndIf      EndIf    ;-- is there any data ?  If ListSize(d()) = 0    info("Creating xml tree with no data.")  EndIf    ;-- create a new XML tree with the given data  h_xml = xml_new(*c, d())    ;-- is valid XML tree ?  If IsXML(h_xml)        ;--- has XML tree no errors ?    If XMLStatus(h_xml) = #PB_XML_Success            ;---- get size of XML tree in memory      content_size = ExportXMLSize(h_xml)      *content = AllocateMemory(content_size + null_byte)      If *content = 0        FreeXML(h_xml)        warn("Can't allocate memory at pointer [content].")        ProcedureReturn 0      EndIf            ;---- and copy the XML tree to memory      If ExportXML(h_xml, *content, content_size) = 0        FreeXML(h_xml)        FreeMemory(*content)        warn("Can't export XML database to memory.")        ProcedureReturn 0      EndIf            ;---- allocate memory for decrypted data      *decrypted = AllocateMemory(content_size + null_byte)      If *decrypted = 0        FreeXML(h_xml)        FreeMemory(*content)        warn("Can't allocate memory at pointer [decrypted].")        ProcedureReturn 0      EndIf            ;---- ask for password      *key = AllocateMemory(#APP_KEY_SIZE)      get_pwd(*key, #True)            ;---- begin decryption      If AESEncoder(*content, *decrypted, content_size, *key, #APP_AES_SIZE, *vec, #PB_Cipher_CBC)                FreeMemory(*content) : clear_mem(*key)                ;----- create the file        h_file = CreateFile(#PB_Any, filename$)        If IsFile(h_file)                    ;------ write header and decrypted data          WriteLong(h_file, #APP_EXT_L)          WriteData(h_file, *vec, #APP_VEC_SIZE)          WriteLong(h_file, content_size)          WriteData(h_file, *decrypted, content_size + null_byte)                    CloseFile(h_file)                    FreeMemory(*decrypted)                  Else                    ;------ break-> can't create file          FreeMemory(*decrypted)          warn("Can't create file '" + filename$ + "'")          ProcedureReturn #Null                  EndIf              Else                ;----- break-> decryption failure        FreeMemory(*content)        FreeMemory(*decrypted)        warn("Can't create decrypted data.")        ProcedureReturn #Null              EndIf          Else            ;--- break-> XML tree has errors      warn("Created xml tree with error: " + XMLError(h_xml) + ", at line " + XMLErrorLine(h_xml) + " and at column " + XMLErrorPosition(h_xml) + ".")      FreeXML(h_xml)      ProcedureReturn #Null          EndIf      Else        ;-- break-> can't create XML tree    warn("Can't create new xml tree.")    ProcedureReturn #Null      EndIf    FreeXML(h_xml)    ProcedureReturn FileSize(filename$)    ;- end xml_save_crypted()EndProcedure;--------------------------------------------------------------------------------; IDE Options = PureBasic 5.73 LTS (Windows - x64); CursorPosition = 205; FirstLine = 347; Folding = 5-; EnableXP; UseMainFile = main.pb; CompileSourceDirectory; EnablePurifier; EnableCompileCount = 0; EnableBuildCount = 0; EnableExeConstant